# DPS (Distributed Permit System) - Technical Report

## 1) DPS System (Individual Project)

**Objective:** To develop a comprehensive, role-based distributed permit management system that enables seamless creation, approval, tracking, and closure of work permits across multiple departments with real-time collaboration, comprehensive analytics, and secure access control.

**Technologies Used:** React 18.3, TypeScript 5.9, Vite 7.1, Express 5.1, Tailwind CSS 3.4, Radix UI component library, React Hook Form with Zod schema validation, React Query (TanStack Query) for state management, Recharts for data visualization, Framer Motion for animations, React Router DOM for client-side navigation, PostCSS for CSS processing, Netlify Functions for serverless backend deployment

> **Project Background:** The DPS System is a sophisticated enterprise-grade permit management platform designed for managing various types of work permits including High Tension (HT) permits, Gas permits, and work closure flows. The system supports multiple user roles (Requester, Approver, Safety Officer, Administrator) with granular permissions, enabling organizations to streamline their permit workflows while maintaining compliance and safety standards.

### ➢ Modules Used:

#### Frontend Module:
**Technologies Used:** React 18.3, TypeScript, Vite with React SWC compiler, Tailwind CSS 3.4, Radix UI (@radix-ui packages), React Hook Form, Zod validation, React Router DOM, React Query (@tanstack/react-query), Recharts, Framer Motion, Lucide React icons

**Details:** I developed a modern, interactive frontend using React 18 with TypeScript for type safety and optimal developer experience. The client-side application is built with Vite as the build tool, leveraging the fast React SWC compiler for rapid development and optimized production builds. I implemented a comprehensive component system using Radix UI primitives, which provided accessible, unstyled components that I styled with Tailwind CSS utility classes. The form handling is managed through React Hook Form integrated with Zod for runtime schema validation, ensuring robust form state management and data validation across complex multi-step permit forms. I integrated React Query for efficient server state management, providing features like automatic caching, synchronization, and stale data handling. The application features real-time data visualization through Recharts for displaying permit analytics, user statistics, and system performance metrics across multiple dashboard views. I implemented smooth animations and transitions using Framer Motion to enhance user experience during form submissions and page transitions. Navigation is handled through React Router DOM with role-based route protection, enabling seamless navigation across multiple permit types and approval workflows.

#### Backend Module:
**Technologies Used:** Express 5.1, Node.js, TypeScript, CORS middleware, environment-based configuration, Express middleware stack, Netlify Functions for serverless deployment

**Details:** I developed a lightweight Express-based backend architecture that provides RESTful API endpoints for client-server communication. The server is configured with CORS middleware to enable secure cross-origin requests from the frontend application. I implemented environment variable management through dotenv to handle configuration across development, staging, and production environments. The backend follows a middleware-driven architecture where requests are processed through multiple layers including body parsing (JSON and URL-encoded), CORS handling, and route handlers. I structured the API with separation of concerns by organizing routes into dedicated handler modules (demo.ts) that maintain clean separation between business logic and HTTP request handling. The backend is deployed as Netlify Functions, leveraging serverless architecture for automatic scaling and reduced infrastructure overhead. The server configuration supports both development mode with hot-reload and production builds with optimized Node.js targets, ensuring efficient performance across deployment stages.

#### Database Module:
**Technologies Used:** Not currently implemented in production code (Placeholder structure), Zod schemas for data validation, Local storage for client-side draft management, Audit trail logging architecture

**Details:** While the current implementation includes placeholder database structures and in-memory data handling, I architected a comprehensive data model supporting complex permit lifecycle management. The system uses Zod schema validation to enforce data integrity at the application layer, with TypeScript types ensuring compile-time and runtime type safety. I implemented a robust data structure for permit forms that tracks multiple workflow states including basic details, work authorization, de-energization procedures, permit-to-work documentation, pre-execution checklists, job completion status, re-energization instructions, and final authorization. The permit data model includes automatic timestamp management (createdAt, updatedAt) for audit compliance. I designed an audit trail system that tracks all permit-related events with ISO timestamps and action metadata for regulatory compliance and historical tracking. Client-side draft management leverages browser local storage with structured envelope patterns containing both the permit data and associated audit events, enabling offline-first workflows. The schema design supports multi-role collaboration with separate comment threads for different stakeholder types (Requester, Approver, Safety Officer), maintaining clear audit trails of all communications and approvals throughout the permit lifecycle.

---

### ➢ Approach:

**Initial Architecture & Module Integration:** I architected the entire DPS system as a full-stack TypeScript application with clear separation between frontend, backend, and shared domains. I established the monorepo structure using Vite as the unified build system, configuring separate entry points for client SPA builds and server Node.js builds through vite.config.ts and vite.config.server.ts respectively. I created shared TypeScript types and interfaces (ht-permit-types.ts) that are consumed by both client and server, enabling type safety across the application boundary. The build pipeline was configured to generate optimized client artifacts (dist/spa) for deployment and server bundles (dist/server) as Node.js compatible modules, with automatic transpilation of TypeScript to JavaScript.

**Frontend Development & Component System:** I developed a comprehensive React component library organized into functional modules: UI components (20+ Radix UI-based components), layout components (Header, Layout, NavTabs with role-based rendering), permit-specific components (PermitFilters, PermitPreview, PermitStatusCard, PermitStatusTable), and chart components (AdminBarChart, AdminLineChart, ContractorKpisChart, etc.). I implemented complex multi-step form workflows using React Hook Form with conditional rendering based on user roles and permit status. The permit detail page (PermitDetails.tsx) showcases advanced React patterns including useEffect hooks for side effects, useMemo for performance optimization, useState for component state management, and useRef for imperative DOM access during file uploads. I created role-based navigation using React Router with protected routes that conditionally render UI based on user permissions defined in the roles.ts configuration file.

**State Management & Data Flow:** I configured React Query (TanStack Query) as the primary client state management solution, providing automatic caching, background synchronization, and stale data invalidation. The QueryClientProvider wraps the entire application tree, enabling all components to access server state seamlessly. I implemented custom hooks for permit data fetching, filtering, and pagination, with debounced search functionality in PermitFilters component to optimize network requests. Form state is managed through controlled components pattern with React Hook Form, providing efficient updates without unnecessary re-renders. I structured the application with a TooltipProvider wrapper for consistent tooltip behavior across all interactive elements using Radix UI's tooltip primitives.

---

### ➢ Challenges:

**Complex Multi-Step Form State Management:** The permit forms require managing state across 7-8 sequential steps with inter-step dependencies, conditional field visibility based on answers, and signature image data URLs that exceed typical form size limits. I solved this by implementing a hierarchical state structure (stepData object) that isolates each step's state, allowing independent updates without triggering re-renders across the entire form. I utilized React Hook Form's nested field naming convention combined with useMemo hooks to optimize re-renders, computing derived state only when dependencies change. For signature handling, I implemented a SignaturePad component that captures canvas data as data URLs, then stores them in the form state only when explicitly saved by users, preventing unnecessary state bloat.

**Role-Based Access Control & Permission Management:** The system supports four distinct user roles (Requester, Approver, Safety Officer, Administrator) with overlapping and specific permissions, requiring granular UI state management. I created a centralized roles.ts configuration file that defines role metadata (label, color, description, path) and integrated role detection logic in the Auth page that reads from URL parameters and persists to localStorage. I implemented conditional rendering throughout the application using role-based state, where navigation tabs, available actions, and form fields dynamically appear based on the current user's role retrieved from localStorage. The RolesPermissions page showcases a permission matrix with three states (none, conditional, full) allowing administrators to manage role capabilities programmatically.

**Real-Time Data Visualization & Analytics Dashboard:** The dashboard required displaying multiple metric types (counters, charts, timeline data) with different data aggregation strategies across administrator, requester, approver, and safety officer views. I solved this using Recharts for declarative chart components (BarChart, LineChart) with custom tooltip formatters and legends. I implemented useMemo hooks in the Index.tsx page to compute counter statistics from mock data sources, ensuring calculations only recalculate when dependencies change. I created separate chart components for each user role, each with tailored datasets and visual presentations, allowing the dashboard to display role-specific metrics efficiently without fetching unnecessary data.

---

### ➢ Features:

**Multi-Step Permit Form Wizard:** Developed a sophisticated permit creation workflow spanning 7-8 sequential steps including Basic Details (power line, plant, validity period), Work Authorization (signatures), De-Energization Checklist, Permit-to-Work documentation, Pre-Execution Checklist, Job Completion status, Re-Energization Instructions, and final Authorization. I implemented FormWizard component with step navigation, validation at each step, and automatic progression with error handling. The form captures structured data with TypeScript interfaces (PermitFormData, DeEnergizeStep, etc.), digital signatures through canvas-based SignaturePad component, and date-time ranges with separate date/time pickers for precise scheduling. The feature includes draft auto-save functionality and visual progress indicators, making complex permit creation manageable for non-technical users while maintaining compliance requirements.

**Dynamic Dashboard with Role-Based Analytics:** Implemented a comprehensive dashboard (Index.tsx page) that displays different metrics and visualizations based on user role. Requester view shows permits submitted, approved, pending counts; Approver view displays approval queue length and pending reviews; Safety Officer view shows safety alerts and compliance metrics; Administrator view presents user management statistics, system activity, and performance trends. I created custom chart components using Recharts that visualize data across multiple dimensions with interactive tooltips and legends. The dashboard features status cards with icon-based visual indicators, animated counters, and customizable date range filters for historical analysis. The implementation uses useMemo for performance optimization and lazy-loads chart components only when the dashboard is active.

**Advanced Permit Filtering & Search System:** Developed PermitFilters component with multi-criteria filtering including text search with debouncing, plant-based filtering, department filtering, status filtering, date range selection with preset options (Today, This Week, This Month, Last 30 Days), and pagination with configurable page size. The search functionality implements debounced input to prevent excessive filtering operations during rapid typing, optimizing performance with React's built-in debouncing patterns through setTimeout and useEffect cleanup. I integrated filter state management with React Router query parameters, enabling bookmarkable search states and shareable filtered views. The component displays active filter count badges and clear visual indicators of applied filters, enabling users to understand which criteria are currently active. The implementation includes type-safe filter state definitions and memoized filter computations.

**Comprehensive User Management Interface:** Created a Users page enabling administrators to manage system users with capabilities including viewing user directory with employee IDs, emails, departments, roles, and last login timestamps; toggling user active/inactive status through Switch components; assigning roles through dropdown selectors; and opening edit dialogs for bulk permission modifications. The page displays users in a sortable table with Avatar components showing user initials, format timestamps using date-fns library for consistent date presentation, and includes search functionality to filter users by name or email. I implemented Dialog modals for editing user permissions, with Checkbox arrays for selecting multiple permission assignments and Switch toggles for fine-grained role settings. The feature supports bulk operations through multi-select checkboxes, enabling administrators to modify multiple users simultaneously.

**Work Closure Request & Approval Workflows:** Implemented comprehensive work closure management with two complementary flows: WorkClosureRequest page allows contractors to submit completion documentation including textual description of work completed, completion date-time selection, checklist confirmation (6 items for verification), and file attachment with upload progress tracking and error handling; WorkClosureApproval page enables supervisors to review submissions with approval/rejection capabilities and comment threads. The request workflow includes drag-drop file upload zones, file size validation with error messaging, and preview generation for image attachments. I implemented file state management tracking upload progress, success status, and error states separately for each file. The approval workflow displays pending requests in prioritized queues with requester details, submitted documents, and decision buttons, streamlining the approval process.

**Role-Based Navigation & Access Control:** Developed NavTabs component that dynamically renders navigation tabs based on the current user's role stored in localStorage, with role metadata sourced from roles.ts configuration. Each role receives a custom set of available pages: Requester can access permit creation and personal tracking; Approver can access approval queues and decision workflows; Safety Officer can access safety alerts and compliance reports; Administrator can access user management, roles/permissions configuration, and system analytics. I implemented navigation guards using React Router where protected routes check localStorage for role authorization before rendering content. The navigation includes visual indicators for the current user's role with color-coding from role metadata (blue for requester, green for approver, amber for safety, purple for admin), making role context always visible to users.

---

## Summary

This project demonstrates mastery of modern full-stack web development with TypeScript, implementing enterprise-grade patterns for state management, form handling, role-based access control, and real-time data visualization. The DPS System serves as a production-ready platform for industrial permit management, showcasing sophisticated architecture decisions and comprehensive feature implementation across frontend, backend, and deployment infrastructure.
